Source: dacite
Section: python
Priority: optional
Maintainer: Debian Python Team <team+python@tracker.debian.org>
Uploaders: Valentin Vidic <vvidic@debian.org>
Build-Depends:
 debhelper-compat (= 13),
 dh-python,
 python3-all,
 python3-pytest,
 python3-pytest-benchmark,
 python3-setuptools,
Standards-Version: 4.6.2
Rules-Requires-Root: no
Homepage: https://github.com/konradhalas/dacite
Vcs-Git: https://salsa.debian.org/python-team/packages/dacite.git
Vcs-Browser: https://salsa.debian.org/python-team/packages/dacite

Package: python3-dacite
Architecture: all
Depends: ${misc:Depends}, ${python3:Depends},
Description: Simple creation of data classes from dictionaries
 Passing plain dictionaries as a data container between your functions or
 methods isn't a good practice. Of course you can always create your
 custom class instead, but this solution is an overkill if you only want
 to merge a few fields within a single object.
 .
 Fortunately Python has a good solution to this problem - data classes.
 Thanks to `@dataclass` decorator you can easily create a new custom
 type with a list of given fields in a declarative manner. Data classes
 support type hints by design.
 .
 However, even if you are using data classes, you have to create their
 instances somehow. In many such cases, your input is a dictionary - it
 can be a payload from a HTTP request or a raw data from a database. If
 you want to convert those dictionaries into data classes, `dacite` is
 your best friend.
 .
 This library was originally created to simplify creation of type hinted
 data transfer objects (DTO) which can cross the boundaries in the
 application architecture.
 .
 It's important to mention that `dacite` is not a data validation library.
 There are dozens of awesome data validation projects and it doesn't make
 sense to duplicate this functionality within `dacite`. If you want to
 validate your data first, you should combine `dacite` with one of data
 validation library.
